// Generated by gencpp from file iarc_arena_simulator/IARCQuadStatus.msg
// DO NOT EDIT!


#ifndef IARC_ARENA_SIMULATOR_MESSAGE_IARCQUADSTATUS_H
#define IARC_ARENA_SIMULATOR_MESSAGE_IARCQUADSTATUS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace iarc_arena_simulator
{
template <class ContainerAllocator>
struct IARCQuadStatus_
{
  typedef IARCQuadStatus_<ContainerAllocator> Type;

  IARCQuadStatus_()
    : header()
    , seq(0)
    , tms(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , vx(0.0)
    , vy(0.0)
    , vz(0.0)
    , ax(0.0)
    , ay(0.0)
    , az(0.0)
    , q0(0.0)
    , q1(0.0)
    , q2(0.0)
    , q3(0.0)  {
    }
  IARCQuadStatus_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , seq(0)
    , tms(0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , vx(0.0)
    , vy(0.0)
    , vz(0.0)
    , ax(0.0)
    , ay(0.0)
    , az(0.0)
    , q0(0.0)
    , q1(0.0)
    , q2(0.0)
    , q3(0.0)  {
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _seq_type;
  _seq_type seq;

   typedef uint32_t _tms_type;
  _tms_type tms;

   typedef float _x_type;
  _x_type x;

   typedef float _y_type;
  _y_type y;

   typedef float _z_type;
  _z_type z;

   typedef float _vx_type;
  _vx_type vx;

   typedef float _vy_type;
  _vy_type vy;

   typedef float _vz_type;
  _vz_type vz;

   typedef float _ax_type;
  _ax_type ax;

   typedef float _ay_type;
  _ay_type ay;

   typedef float _az_type;
  _az_type az;

   typedef float _q0_type;
  _q0_type q0;

   typedef float _q1_type;
  _q1_type q1;

   typedef float _q2_type;
  _q2_type q2;

   typedef float _q3_type;
  _q3_type q3;




  typedef boost::shared_ptr< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> const> ConstPtr;

}; // struct IARCQuadStatus_

typedef ::iarc_arena_simulator::IARCQuadStatus_<std::allocator<void> > IARCQuadStatus;

typedef boost::shared_ptr< ::iarc_arena_simulator::IARCQuadStatus > IARCQuadStatusPtr;
typedef boost::shared_ptr< ::iarc_arena_simulator::IARCQuadStatus const> IARCQuadStatusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace iarc_arena_simulator

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'iarc_arena_simulator': ['/home/exbot/workspace/hehualin_ws/distribute/src/iarc_arena_simulator/msg'], 'nav_msgs': ['/opt/ros/indigo/share/nav_msgs/cmake/../msg'], 'actionlib_msgs': ['/opt/ros/indigo/share/actionlib_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/indigo/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/indigo/share/geometry_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8c93a9c3d368e8425fdce057db853f5e";
  }

  static const char* value(const ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8c93a9c3d368e842ULL;
  static const uint64_t static_value2 = 0x5fdce057db853f5eULL;
};

template<class ContainerAllocator>
struct DataType< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "iarc_arena_simulator/IARCQuadStatus";
  }

  static const char* value(const ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# waypoint\n\
Header header\n\
uint32 seq\n\
uint32 tms\n\
float32 x\n\
float32 y\n\
float32 z\n\
float32 vx\n\
float32 vy\n\
float32 vz\n\
float32 ax\n\
float32 ay\n\
float32 az\n\
float32 q0\n\
float32 q1\n\
float32 q2\n\
float32 q3\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.seq);
      stream.next(m.tms);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.vx);
      stream.next(m.vy);
      stream.next(m.vz);
      stream.next(m.ax);
      stream.next(m.ay);
      stream.next(m.az);
      stream.next(m.q0);
      stream.next(m.q1);
      stream.next(m.q2);
      stream.next(m.q3);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct IARCQuadStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::iarc_arena_simulator::IARCQuadStatus_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "seq: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.seq);
    s << indent << "tms: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.tms);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<float>::stream(s, indent + "  ", v.z);
    s << indent << "vx: ";
    Printer<float>::stream(s, indent + "  ", v.vx);
    s << indent << "vy: ";
    Printer<float>::stream(s, indent + "  ", v.vy);
    s << indent << "vz: ";
    Printer<float>::stream(s, indent + "  ", v.vz);
    s << indent << "ax: ";
    Printer<float>::stream(s, indent + "  ", v.ax);
    s << indent << "ay: ";
    Printer<float>::stream(s, indent + "  ", v.ay);
    s << indent << "az: ";
    Printer<float>::stream(s, indent + "  ", v.az);
    s << indent << "q0: ";
    Printer<float>::stream(s, indent + "  ", v.q0);
    s << indent << "q1: ";
    Printer<float>::stream(s, indent + "  ", v.q1);
    s << indent << "q2: ";
    Printer<float>::stream(s, indent + "  ", v.q2);
    s << indent << "q3: ";
    Printer<float>::stream(s, indent + "  ", v.q3);
  }
};

} // namespace message_operations
} // namespace ros

#endif // IARC_ARENA_SIMULATOR_MESSAGE_IARCQUADSTATUS_H
